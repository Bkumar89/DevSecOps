docker ps - to see the running list of containers.

docker ps -a - to see all the running or stopped containers.

docker image ls - to see all the images in local.

docker rmi -f <imageid1> <imageid2> <imageid3> .... - to delete the images from local.

docker rm -f <containerid1> <containerid2> <containerid3> ...... - to delete the running containers forcefully.

docker stop <containerid1> <containerid2> <containerid3> .....  - to stop the running container.

To build the Docker image from docker file:
docker build -t <imagename> -f <dockerfilename> <pathof thedocker contextroot directroy>
example - docker build -t bishkumar/tomcat_jenkins:9.0.29 -f Dockerfile .

To create the container from image:
docker run -it -d -p <hostport>:<containerport> --name <containername> <imagename> <terminal like /bin/bash>
example: docker run -it -d -p 9090:8080 --name myjenkins bishkumar/tomcat_jenkins:9.0.29 /bin/bash

To login to the docker container:
docker exec -it <containerid/name> bash
or
docker attach <containername/id>
example - docker exec -it myjenkins

Copy file from docker conatiner to local host:
synatx: docker cp <src> <dest>
docker cp <containername/containerid>:<filepath> <hostpath>
docker cp <containername/containerid>:/opt/tomcat/logs/catalina.out /home/ubuntu

Copy file to docker conatiner from local host:
docker cp  /home/ubuntu/file1.txt <containername/containerid>:/opt/tomcat/logs/catalina.out

docker attach <conatinername> - after exit from container, it stopped the container.
docker exec -it <containername> bash - after exit from container, it does not stopped the container.

DOCKER VOLUME:
1. Volume
Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker. Volumes have several advantages over bind mounts:
Volumes are easier to back up or migrate than bind mounts.
You can manage volumes using Docker CLI commands or the Docker API.
Volumes work on both Linux and Windows containers.
Volumes can be more safely shared among multiple containers.
Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add other functionality.
New volumes can have their content pre-populated by a container.
Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts.
In addition, volumes are often a better choice than persisting data in a container’s writable layer, because a volume does not increase the size of the containers using it, and the volume’s contents exist outside the lifecycle of a given container.

2. Bind volume
Bind mounts have been around since the early days of Docker. Bind mounts have limited functionality compared to volumes. When you use a bind mount, a file or directory on the host machine is mounted into a container. The file or directory is referenced by its absolute path on the host machine. By contrast, when you use a volume, a new directory is created within Docker’s storage directory on the host machine, and Docker manages that directory’s contents.
The file or directory does not need to exist on the Docker host already. It is created on demand if it does not yet exist. Bind mounts are very performant, but they rely on the host machine’s filesystem having a specific directory structure available. If you are developing new Docker applications, consider using named volumes instead. You can’t use Docker CLI commands to directly manage bind mounts.

3. tmpfs
Volumes and bind mounts let you share files between the host machine and container so that you can persist data even after the container is stopped.
If you’re running Docker on Linux, you have a third option: tmpfs mounts. When you create a container with a tmpfs mount, the container can create files outside the container’s writable layer.
As opposed to volumes and bind mounts, a tmpfs mount is temporary, and only persisted in the host memory. When the container stops, the tmpfs mount is removed, and files written there won’t be persisted.

Using Volume in Docker container:
docker run -it -d -p 5050:8080 -v /opt/appconf:/opt/appconf --name container1 bishkumar/sampledemoproject:5.5.7.0 /bin/bash


DOCKER COMPOSE:
Docker Compose is a way to execute multi-container applications. Docker Compose is used to run an application as single service. We define the yaml file for docker compose.

version: "3"
services:
  activemq:
        image: activemq:5.15.11
        container_name: activemq
        ports:
          - "${MQ_PORT}:8161"
          - "${MQ_TCP_PORT}:61616"
        networks:
          - bridge-network
  frmapp:
        image: image1
        container_name: appserver
        ports:
          - "${APP_PORT}:8080"
        networks:
          - bridge-network
        environment:
          - ACTIVEMQ_TCP_URL=${ACTIVEMQ_TCP_URL}
          - DRIVER=${DRIVER}
          - JDBC_URL=${JDBC_URL}
          - SCHEMA_PASS=${SCHEMA_PASS}
          - SCHEMA=${SCHEMA}
          - FRM_CONFIG=${FRM_CONFIG}
        volumes:
          - ${FRM_CONFIG}:/opt/app/app-1.3.5
  guvapp:
        image: image2
        container_name: rule_guvnor
        ports:
          - "${GUVNOR_PORT}:8080"
        networks:
          - bridge-network
        volumes:
          - /opt/guvnor/drools_repo:/opt/guvnor/drools_repo
networks:
  bridge-network:
  

docker compose env file:
DRIVER=oracle.jdbc.driver.OracleDriver
JDBC_URL=jdbc:oracle:thin:@ip:1521/FRM
ACTIVEMQ_TCP_URL=tcp://ip:14616
SCHEMA_PASS=oracle
SCHEMA=app135_Release
MQ_PORT=8161
MQ_TCP_PORT=14616
APP_PORT=9090
FRM_CONFIG=/opt/app
GUVNOR_PORT=6060

docker compose instructions:
Run the below command to start the compose.
Start:
docker-compoe --env-file frm_oracle.env up -d

Stop:
docker-compose --env-file frm_oracle.env down


